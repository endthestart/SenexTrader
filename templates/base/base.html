<!DOCTYPE html>
<html lang="en" data-bs-theme="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{% block title %}Senex Trader{% endblock %}</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.1/font/bootstrap-icons.css" rel="stylesheet">
    {% load static %}
    <link rel="stylesheet" href="{% static 'css/dark-theme.css' %}">
    {% block extra_css %}{% endblock %}
</head>
<body class="bg-dark text-light">
    <nav class="navbar navbar-expand-lg navbar-dark bg-dark border-bottom border-secondary">
        <div class="container">
            <a class="navbar-brand fw-bold" href="{% url 'home' %}" style="color: var(--accent-color);">Senex Trader</a>
            <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNav">
                <span class="navbar-toggler-icon"></span>
            </button>
            <div class="collapse navbar-collapse" id="navbarNav">
                <ul class="navbar-nav me-auto">
                    {% if user.is_authenticated %}
                        <li class="nav-item"><a class="nav-link" href="{% url 'dashboard' %}">Dashboard</a></li>
                        <li class="nav-item"><a class="nav-link" href="{% url 'trading:trading' %}">Trading</a></li>
                        <li class="nav-item"><a class="nav-link" href="{% url 'trading:senex_trident' %}">Trident</a></li>
                        <li class="nav-item"><a class="nav-link" href="{% url 'trading:positions' %}">Positions</a></li>
                        <li class="nav-item"><a class="nav-link" href="{% url 'trading:orders' %}">Orders</a></li>
                        <li class="nav-item"><a class="nav-link" href="{% url 'trading:watchlist' %}">Watchlist</a></li>
                        <li class="nav-item"><a class="nav-link" href="{% url 'accounts:settings' %}">Settings</a></li>
                    {% endif %}
                </ul>
                <ul class="navbar-nav">
                    {% if user.is_authenticated %}
                        {% if DRY_RUN_MODE %}
                        <li class="nav-item">
                            <span class="nav-link text-warning" title="Dry-run mode active - orders validated without database writes">
                                <i class="bi bi-exclamation-triangle-fill"></i> <span class="fw-bold">DRY-RUN MODE</span>
                            </span>
                        </li>
                        {% endif %}
                        <li class="nav-item">
                            <span class="nav-link" id="streaming-status-badge" style="display: none;">
                                <i class="bi bi-wifi"></i> <span id="badge-text">Connecting...</span>
                            </span>
                        </li>
                        <li class="nav-item dropdown">
                            <a class="nav-link dropdown-toggle" href="#" role="button" data-bs-toggle="dropdown">
                                {{ user.full_name|default:user.email }}
                            </a>
                            <ul class="dropdown-menu dropdown-menu-end bg-dark border-secondary">
                                <li><a class="dropdown-item text-light" href="{% url 'accounts:profile' %}">Profile</a></li>
                                <li><hr class="dropdown-divider border-secondary"></li>
                                <li>
                                    <form method="post" action="{% url 'accounts:logout' %}" class="d-inline">
                                        {% csrf_token %}
                                        <button type="submit" class="dropdown-item text-light">Logout</button>
                                    </form>
                                </li>
                            </ul>
                        </li>
                    {% else %}
                        <li class="nav-item"><a class="nav-link" href="{% url 'accounts:login' %}">Login</a></li>
                        <li class="nav-item"><a class="nav-link" href="{% url 'accounts:register' %}">Register</a></li>
                    {% endif %}
                </ul>
            </div>
        </div>
    </nav>

    <main class="container mt-4">
        {% if messages %}
            {% for message in messages %}
                <div class="alert alert-{{ message.tags|default:'info' }} alert-dismissible fade show" role="alert">
                    {{ message }}
                    <button type="button" class="btn-close" data-bs-dismiss="alert"></button>
                </div>
            {% endfor %}
        {% endif %}

        {% block content %}{% endblock %}
    </main>

    <!-- Reusable Confirmation Modal -->
    <div class="modal fade" id="confirmModal" tabindex="-1" aria-labelledby="confirmModalTitle" aria-hidden="true">
        <div class="modal-dialog modal-dialog-centered">
            <div class="modal-content bg-dark border-secondary">
                <div class="modal-header bg-secondary">
                    <h5 class="modal-title" id="confirmModalTitle">Confirm Action</h5>
                    <button type="button" class="btn-close btn-close-white" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body" id="confirmModalBody">
                    Are you sure?
                </div>
                <div class="modal-footer bg-secondary">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                    <button type="button" class="btn btn-primary" id="confirmModalConfirmBtn">Confirm</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Generic Result Modal (Success/Error/Info) -->
    <div class="modal fade" id="resultModal" tabindex="-1" aria-labelledby="resultModalTitle" aria-hidden="true">
        <div class="modal-dialog modal-dialog-centered">
            <div class="modal-content" id="resultModalContent">
                <div class="modal-header" id="resultModalHeader">
                    <h5 class="modal-title" id="resultModalTitle">
                        <i id="resultModalIcon" class="bi bi-check-circle-fill me-2"></i>
                        <span id="resultModalTitleText">Result</span>
                    </h5>
                    <button type="button" class="btn-close btn-close-white" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body" id="resultModalBody">
                    <!-- Message content inserted dynamically -->
                </div>
                <div class="modal-footer" id="resultModalFooter">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
                    <!-- Action buttons inserted dynamically -->
                </div>
            </div>
        </div>
    </div>

    <!-- Prompt Modal (for input dialogs) -->
    <div class="modal fade" id="promptModal" tabindex="-1" aria-labelledby="promptModalTitle" aria-hidden="true">
        <div class="modal-dialog modal-dialog-centered">
            <div class="modal-content bg-dark border-secondary">
                <div class="modal-header bg-secondary">
                    <h5 class="modal-title" id="promptModalTitle">Input Required</h5>
                    <button type="button" class="btn-close btn-close-white" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body">
                    <label for="promptModalInput" id="promptModalLabel" class="form-label">Enter value:</label>
                    <input type="text" class="form-control bg-dark text-white border-secondary" id="promptModalInput" placeholder="">
                </div>
                <div class="modal-footer bg-secondary">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                    <button type="button" class="btn btn-primary" id="promptModalConfirmBtn">OK</button>
                </div>
            </div>
        </div>
    </div>

    <footer class="bg-dark border-top border-secondary mt-5 py-4">
        <div class="container text-center text-muted">
            <p>&copy; 2025 Senex Holdings, LLC</p>
        </div>
    </footer>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js"></script>
    {% load static %}
    <script src="{% static 'js/utils.js' %}"></script>
    <script src="{% static 'js/realtime-updater-base.js' %}"></script>

    {% if user.is_authenticated and has_broker_account %}
    <!-- Global Streamer Initialization -->
    <script>
        // Global streamer initialization
        (function() {
            // getCsrfToken() function is available from utils.js

            // Global state
            window.streamersReady = window.streamersReady || false;
            window.streamerWebSocket = window.streamerWebSocket || null;
            window.streamerDetails = window.streamerDetails || {};
            window.reconnectAttempts = window.reconnectAttempts || 0;
            window.reconnectTimeout = window.reconnectTimeout || null;
            window.heartbeatInterval = window.heartbeatInterval || null;

            // Enhanced handler management with unique IDs
            window.messageHandlerRegistry = window.messageHandlerRegistry || new Map();
            window.nextHandlerId = window.nextHandlerId || 1;

            // Utility function to register message handlers with unique IDs
            window.addMessageHandler = function(handler, context) {
                if (typeof handler === 'function') {
                    const id = window.nextHandlerId++;
                    window.messageHandlerRegistry.set(id, {
                        handler: handler,
                        context: context || 'unknown'
                    });
                    console.debug(`Registered handler ${id} from ${context}. Total handlers:`, window.messageHandlerRegistry.size);
                    return id;  // Return ID for removal
                } else {
                    console.error('Handler must be a function');
                    return null;
                }
            };

            // Utility function to remove message handlers by ID
            window.removeMessageHandler = function(handlerId) {
                if (window.messageHandlerRegistry.has(handlerId)) {
                    const handlerInfo = window.messageHandlerRegistry.get(handlerId);
                    window.messageHandlerRegistry.delete(handlerId);
                    console.debug(`Removed handler ${handlerId} (${handlerInfo.context}). Total handlers:`, window.messageHandlerRegistry.size);
                    return true;
                }
                return false;
            };

            // Clear all handlers from a specific context (useful for page cleanup)
            window.clearHandlersByContext = function(context) {
                let removed = 0;
                for (const [id, info] of window.messageHandlerRegistry) {
                    if (info.context === context) {
                        window.messageHandlerRegistry.delete(id);
                        removed++;
                    }
                }
                if (removed > 0) {
                    console.debug(`Cleared ${removed} handlers from context "${context}". Total remaining:`, window.messageHandlerRegistry.size);
                }
                return removed;
            };

            // Simple heartbeat management
            window.startHeartbeat = function() {
                if (!window.heartbeatInterval &&
                    window.streamerWebSocket &&
                    window.streamerWebSocket.readyState === WebSocket.OPEN) {
                    window.heartbeatInterval = setInterval(() => {
                        if (window.streamerWebSocket &&
                            window.streamerWebSocket.readyState === WebSocket.OPEN) {
                            window.streamerWebSocket.send(JSON.stringify({
                                type: 'ping',
                                timestamp: new Date().toISOString()
                            }));
                            console.debug('ðŸ’“ Heartbeat sent');
                        }
                    }, 30000);
                    console.log('Heartbeat started');
                }
            };

            window.clearHeartbeat = function() {
                if (window.heartbeatInterval) {
                    clearInterval(window.heartbeatInterval);
                    window.heartbeatInterval = null;
                    console.log('Heartbeat cleared');
                }
            };

            // OAuth restoration handler - triggers reconnection
            window.handleOAuthRestored = function(data) {
                console.log('OAuth restored, reconnecting...');
                window.reconnectAttempts = 0;
                if (!window.streamerWebSocket || window.streamerWebSocket.readyState !== WebSocket.OPEN) {
                    initializeStreamers();
                }
            };

            // Streaming state persistence functions
            window.saveStreamingState = function(state) {
                try {
                    sessionStorage.setItem('streaming_state', JSON.stringify(state));
                    console.debug('ðŸ’¾ Saved streaming state:', state);
                } catch (error) {
                    console.error('Error saving streaming state:', error);
                }
            };

            window.loadStreamingState = function() {
                try {
                    const stored = sessionStorage.getItem('streaming_state');
                    if (stored) {
                        const state = JSON.parse(stored);
                        console.debug('ðŸ“‹ Loaded streaming state:', state);
                        return state;
                    }
                } catch (error) {
                    console.error('Error loading streaming state:', error);
                }
                return {
                    websocket_connected: false,
                    data_streaming: false,
                    streamers_ready: false,
                    last_update: null
                };
            };

            // Show loading overlay (now uses badge instead)
            function showStreamerLoading(message) {
                updateStreamingBadge('connecting', message || 'Connecting to market data services');
            }

            // Hide loading overlay (now uses badge instead)
            function hideStreamerLoading() {
                updateStreamingBadge('connected', 'Connected to market data');
            }

            // Check streamer status
            async function checkStreamerStatus() {
                try {
                    const response = await fetch('{% url "trading:streamer_status" %}', {
                        method: 'GET',
                        headers: {
                            'X-CSRFToken': getCsrfToken(),
                        }
                    });

                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }

                    const data = await response.json();
                    return data;
                } catch (error) {
                    console.error('Error checking streamer status:', error);
                    return { ready: false, account_ready: false, data_ready: false };
                }
            }

            // Initialize WebSocket and streamers
            async function initializeStreamers() {
                // No special logic needed - oauth_restored message handles reconnection

                window.streamersInitialized = true;  // Mark as initialized

                // CRITICAL FIX: Reuse existing WebSocket connection on page navigation
                // Only create new connection if none exists or it's closed
                if (window.streamerWebSocket && 
                    (window.streamerWebSocket.readyState === WebSocket.OPEN || 
                     window.streamerWebSocket.readyState === WebSocket.CONNECTING)) {
                    console.log('â™»ï¸ Reusing existing WebSocket connection (state:', window.streamerWebSocket.readyState, ')');
                    
                    // If already ready, emit event immediately for new page
                    if (window.streamersReady) {
                        console.log('âœ… Streamers already ready, emitting event for new page');
                        window.dispatchEvent(new CustomEvent('streamers-ready', { 
                            detail: { ready: true, reused: true } 
                        }));
                        return;
                    }
                    
                    // WebSocket exists but streamers not ready - wait for them
                    // This can happen on first page load, after settings nav, or after reconnection
                    console.log('â³ WebSocket exists but streamers not ready, checking status...');
                    // Fall through to the readiness check logic below (don't return)
                } else {
                    // Connect WebSocket
                    console.log('ðŸ”Œ Creating new WebSocket connection');
                    const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
                    const wsUrl = `${protocol}//${window.location.host}/ws/streaming/`;

                    window.streamerWebSocket = new WebSocket(wsUrl);

                    if (window.streamerWebSocket) {
                        window.streamerWebSocket.onopen = async function(e) {
                        console.log('Global WebSocket connection established.');

                        // Reset reconnection state
                        window.reconnectAttempts = 0;
                        if (window.reconnectTimeout) {
                            clearTimeout(window.reconnectTimeout);
                            window.reconnectTimeout = null;
                        }

                        // Start heartbeat
                        clearHeartbeat();
                        startHeartbeat();

                        // Save WebSocket connected state
                        window.saveStreamingState({
                            websocket_connected: true,
                            data_streaming: false,
                            streamers_ready: false,
                            last_update: new Date().toISOString()
                        });
                    };

                    window.streamerWebSocket.onmessage = function(e) {
                        const message = JSON.parse(e.data);

                        // Handle OAuth restoration message
                        if (message.type === 'oauth_restored') {
                            handleOAuthRestored(message);
                        }

                        // Dispatch to all registered handlers from the Map
                        window.messageHandlerRegistry.forEach((handlerInfo, id) => {
                            try {
                                handlerInfo.handler(message);
                            } catch (error) {
                                console.error(`Error in message handler ${id} (${handlerInfo.context}):`, error);
                            }
                        });
                    };

                    window.streamerWebSocket.onerror = function(error) {
                        console.error('Global WebSocket error:', error);
                        updateStreamingBadge('error', 'Connection error');
                    };

                    window.streamerWebSocket.onclose = function(e) {
                        console.log('Global WebSocket connection closed:', e.code, e.reason);
                        window.streamersReady = false;

                        // Clear reconnection timeout and heartbeat
                        if (window.reconnectTimeout) {
                            clearTimeout(window.reconnectTimeout);
                            window.reconnectTimeout = null;
                        }
                        clearHeartbeat();

                        // Save disconnected state
                        window.saveStreamingState({
                            websocket_connected: false,
                            data_streaming: false,
                            streamers_ready: false,
                            last_update: new Date().toISOString()
                        });

                        updateStreamingBadge('error', 'Connection lost');

                        // Don't reconnect for intentional closes
                        if (e.code === 1000 || e.code === 1001) {
                            console.log('Intentional close, not reconnecting');
                            return;
                        }

                        // Check max attempts (10)
                        if (window.reconnectAttempts >= 10) {
                            console.error('Max reconnection attempts reached');
                            updateStreamingBadge('error', 'Connection failed - please refresh');
                            return;
                        }

                        // Exponential backoff reconnection
                        window.reconnectAttempts++;
                        const backoffDelay = Math.min(
                            1000 * Math.pow(2, window.reconnectAttempts),
                            30000
                        );

                        console.log(`Reconnecting in ${backoffDelay}ms (attempt ${window.reconnectAttempts})`);

                        window.reconnectTimeout = setTimeout(() => {
                            initializeStreamers();
                        }, backoffDelay);
                    };
                    } // Close the if (window.streamerWebSocket) block
                }

                // Show loading overlay on trading pages
                const isOnTradingPage = window.location.pathname.includes('/trading/') ||
                                       window.location.pathname.includes('/accounts/settings');
                if (isOnTradingPage) {
                    showStreamerLoading('Initializing streamers...');
                }

                // Wait for streamers to be ready (works for both new and reused WebSocket)
                let attempts = 0;
                const maxAttempts = 30;  // 30 seconds max wait

                // If WebSocket is still connecting, wait for it first
                if (window.streamerWebSocket && window.streamerWebSocket.readyState === WebSocket.CONNECTING) {
                    console.log('Waiting for WebSocket to open...');
                    await new Promise((resolve) => {
                        const checkInterval = setInterval(() => {
                            if (window.streamerWebSocket.readyState === WebSocket.OPEN) {
                                clearInterval(checkInterval);
                                resolve();
                            } else if (window.streamerWebSocket.readyState === WebSocket.CLOSED) {
                                clearInterval(checkInterval);
                                resolve(); // Will fail below
                            }
                        }, 100);
                    });
                }

                while (attempts < maxAttempts) {
                    const status = await checkStreamerStatus();

                    if (status.ready) {
                        window.streamersReady = true;
                        window.streamerDetails = status.details || {};

                        console.log('Streamers ready:', status);
                        hideStreamerLoading();

                        // Save streamers ready state
                        window.saveStreamingState({
                            websocket_connected: true,
                            data_streaming: true,
                            streamers_ready: true,
                            last_update: new Date().toISOString()
                        });

                        // Emit custom event
                        window.dispatchEvent(new CustomEvent('streamers-ready', { detail: status }));
                        break;
                    }

                    // Update status message
                    let message = 'Waiting for streamers...';
                    if (!status.account_ready) {
                        message = 'Loading account data...';
                    } else if (!status.data_ready) {
                        message = 'Connecting to market data...';
                    }

                    if (isOnTradingPage) {
                        showStreamerLoading(message + ` (${attempts + 1}/${maxAttempts})`);
                    }

                    attempts++;
                    await new Promise(resolve => setTimeout(resolve, 1000));  // Wait 1 second
                }

                if (!window.streamersReady) {
                    console.warn('Streamers did not become ready within timeout');
                    hideStreamerLoading();
                    // Still emit event but with not ready status
                    window.dispatchEvent(new CustomEvent('streamers-timeout', { detail: { attempts } }));
                }

                // Start heartbeat to track user activity (managed in onopen now)
                // This code is replaced by startHeartbeat() called in onopen
                // Legacy heartbeat will be handled by the new startHeartbeat function
            }

            // Export critical functions to global scope for external access
            window.initializeStreamers = initializeStreamers;
            window.checkStreamerStatus = checkStreamerStatus;
            window.showStreamerLoading = showStreamerLoading;
            window.hideStreamerLoading = hideStreamerLoading;

            // Initialize on page load
            document.addEventListener('DOMContentLoaded', function() {
                console.log('Initializing global streamers...');
                initializeStreamers();
            });
        })();
    </script>
    {% endif %}

    {% block extra_js %}{% endblock %}
</body>
</html>
